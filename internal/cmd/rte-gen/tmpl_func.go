package main

import (
	"bytes"
	"fmt"
	"io"
	"text/template"
)

var (
	tmplFunc = template.Must(template.New("").Parse(`
// Code generated by cmd/rte-gen/gen.go DO NOT EDIT.
package funcs

import (
	"fmt"
	"net/http"
)

const (
	maxVars = {{ .MaxVars }}
)

// PathVars is a fixed size array used to back the maximum number of possible path variables.
type PathVars [maxVars]string

// Handler is a handler function permitting no-allocation handling of path variables
type Handler func(w http.ResponseWriter, r *http.Request, pathVars PathVars)

// Convert converts the provided interface to a Handler if possible.
func Convert(i interface{}) (Handler, int, error) {
	switch v := i.(type) {
	case http.Handler:
		return {{ .ZeroFuncName }}(v.ServeHTTP), 0, nil
{{- range $sig := .Signatures }}
{{- if and (not .Arr) (gt .Count 0) }}
	case func(w http.ResponseWriter, r *http.Request, {{ range $idx, $p := .PNames }}{{ if $idx }}, {{ end }}{{ $p }}{{ end }} string):
{{- else if eq .Count 0 }}
	case func(w http.ResponseWriter, r *http.Request):
{{- else if eq .Count $.MaxVars }}
	case func(w http.ResponseWriter, r *http.Request, pVars [maxVars]string):
{{- else }}
	case func(w http.ResponseWriter, r *http.Request, pVars [{{ .Count }}]string):
{{- end }}
		return {{ .Name }}(v), {{ .Count }}, nil
{{- end }}
	default:
		return nil, 0, fmt.Errorf("unknown handler type: %T", i)
	}
}

// generated handler wrappers which avoid allocs

{{ range $sig := .Signatures }}
{{ if and (not .Arr) (gt .Count 0) }}
// {{ .Name }} takes in a standard http handler also expecting {{ .Count }} path variable values and returns a valid bound handler
func {{ .Name }}(f func(w http.ResponseWriter, r *http.Request, {{ range $idx, $p := .PNames }}{{ if $idx }}, {{ end }}{{ $p }}{{ end }} string)) Handler {
	return func(w http.ResponseWriter, r *http.Request, pVars PathVars) {
		f(w, r, {{ range $idx, $el := .PNames }}{{ if $idx }}, {{ end }}pVars[{{ $idx }}]{{ end }})
    }
}
{{ else if eq .Count 0 }}
// {{ .Name }} takes in a no path variable handler and returns a Handler fit for static paths
func {{ .Name }}(f func(w http.ResponseWriter, r *http.Request)) Handler {
	return func(w http.ResponseWriter, r *http.Request, _ PathVars) {
		f(w, r)
	}
}
{{ else if eq .Count $.MaxVars }}
// {{ .Name }} takes in handler expecting array of {{ $.MaxVars }} path variable values and returns a valid handler
func {{ .Name }}(f func(w http.ResponseWriter, r *http.Request, pVars [maxVars]string)) Handler {
	return func(w http.ResponseWriter, r *http.Request, pVars PathVars) {
		f(w, r, [maxVars]string(pVars))
	}
}
{{ else }}
// {{ .Name }} takes in handler expecting array of {{ .Count }} path variable values and returns a valid handler
func {{ .Name }}(f func(w http.ResponseWriter, r *http.Request, pVars [{{ .Count }}]string)) Handler {
	return func(w http.ResponseWriter, r *http.Request, pVars PathVars) {
		var trimmed [{{ .Count }}]string
		copy(trimmed[:], pVars[:])
		f(w, r, trimmed)
	}
}
{{ end }}
{{ end }}
`))
)

func writeFunctionFile(w io.Writer, sigs []Signature) error {
	var maxVar int
	for _, s := range sigs {
		if s.Count > maxVar {
			maxVar = s.Count
		}
	}

	var buf bytes.Buffer
	if err := tmplFunc.Execute(&buf, struct {
		Signatures   []Signature
		MaxVars      int
		ZeroFuncName string
	}{
		sigs,
		maxVar,
		zeroFuncName,
	}); err != nil {
		return fmt.Errorf("tmplFunc.Execute: %v", err)
	}

	return writeFormatted(buf.Bytes(), w)
}
