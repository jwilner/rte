package main

import (
	"bytes"
	"fmt"
	"io"
	"sort"
	"text/template"
)

var (
	tmplFunc = template.Must(template.New("").Parse(`
package rte

import (
{{ range $imp := .Imports }}
	"{{ $imp }}"
{{ end }}
)

// generated handler wrappers which avoid allocs
// do not edit this file!

{{ range $sig := .Sigs }}
// {{ $sig.FuncName }} creates a route which matches the supplied method and path. In addition to a response writer, and
// a request object, the provided handler requires the matched path contain in order:
{{- range $grp := $sig.ParamGroups }}
// - {{ len $grp.Names }} {{ $grp.Type.Desc }}{{ if gt (len $grp.Names) 1 }}s{{end}}
{{- end }}
func {{ $sig.FuncName }}(
	method,
	path string,
	f func(
		w http.ResponseWriter,
		r *http.Request,
		{{- range $g := $sig.ParamGroups }}
		{{ range $idx, $p := $g.Names -}}{{ if $idx }}, {{end}}{{ $p }}{{- end }} {{$g.Type.Name}},
		{{end -}}
	),
) Route {
	return Bind(method, path, {{ $sig.TypeName }}(f))
}

type {{ $sig.TypeName }} func(
	w http.ResponseWriter,
	r *http.Request,
	{{ range $g := $sig.ParamGroups }}
	{{- range $idx, $p := $g.Names -}}{{if $idx }}, {{end}}{{ $p }}{{- end }} {{$g.Type.Name}},
	{{end -}}
)

func (f {{ $sig.TypeName }}) Bind(segIdxes []int) (http.HandlerFunc, error) {
	if len(segIdxes) != {{ len $sig.Params }} {
		return nil, ErrWrongNumParams
	}

	return func(w http.ResponseWriter, r *http.Request) {
		var segs [{{ len $sig.Params }}]string
		findNSegments(r.URL.Path, segIdxes[:], segs[:])
		{{- range $idx, $p := $sig.Params }}
		{{ if index $p.Type.Conv 0 }}
		{{$p.Name}}, err := {{ index $p.Type.Conv 0 }}segs[{{ $idx }}]{{ index $p.Type.Conv 1 }}
		if err != nil {
			panic(err)
		}
		{{ end }}
		{{ end }}
		f(
			w,
			r,
			{{- range $idx, $p := $sig.Params -}}
			{{- if index $p.Type.Conv 0 }}
			{{ $p.Name }},
			{{- else }}
			segs[{{ $idx }}],
			{{ end }}
			{{- end }}
		)
	}, nil
}
{{ end }}
`))
)

func writeFunctionFile(w io.Writer, sigs []sig) error {
	imports := []string{"net/http"}
	{
		seen := make(map[string]bool)
		for _, sig := range sigs {
			for _, p := range sig.Params {
				for _, i := range p.Type.Imports {
					if !seen[i] {
						seen[i] = true
						imports = append(imports, i)
					}
				}
			}
		}
		sort.Strings(imports)
	}

	var buf bytes.Buffer
	if err := tmplFunc.Execute(&buf, struct {
		Sigs    []sig
		Imports []string
	}{sigs, imports}); err != nil {
		return fmt.Errorf("tmplFunc.Execute: %v", err)
	}

	return writeFormatted(buf.Bytes(), w)
}
