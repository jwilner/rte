package main

import (
	"bytes"
	"fmt"
	"io"
	"sort"
	"text/template"
)

var (
	tmplFunc = template.Must(template.New("").Parse(`
package rte

import (
{{ range $imp := .Imports }}
	"{{ $imp }}"
{{ end }}
)

// generated handler wrappers which avoid allocs
// do not edit this file!

{{ range $sig := .Sigs }}
{{- if gt (len $sig.Params) 0 }}
// {{ $sig.TypeName }} is a binding handler which matches a route with a specific signature. In addition to a response 
// writer, and a request object, the provided handler requires the matched path contain in order:
{{- else }}
// {{ $sig.TypeName }} is a binding handler which routes requests without any path variables. It exists only to make
// http.HandlerFunc satisfy the Binder interface.
{{- end }}
{{- range $grp := $sig.ParamGroups }}
// - {{ len $grp.Names }} {{ $grp.Type.Desc }}{{ if gt (len $grp.Names) 1 }}s{{end}}
{{- end }}
type {{ $sig.TypeName }} func(
	w http.ResponseWriter,
	r *http.Request,
	{{ range $g := $sig.ParamGroups }}
	{{- range $idx, $p := $g.Names -}}{{if $idx }}, {{end}}{{ $p }}{{- end }} {{$g.Type.Name}},
	{{end -}}
)

// Bind takes in the segment indices from which handler logic should extract path variables (if any) and returns an 
// http.Handler or an error on misconfiguration.
func (f {{ $sig.TypeName }}) Bind(bCtx BindContext) (http.Handler, error) {
	if len(bCtx.ParamPos) != {{ len $sig.Params }} {
		return nil, ErrWrongNumParams
	}

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		{{- if gt (len $sig.Params) 0 }}
		var segs [{{ len $sig.Params }}]string
		findNSegments(r.URL.Path, bCtx.ParamPos[:], segs[:])
		{{- range $idx, $p := $sig.Params }}
		{{ if index $p.Type.Conv 0 }}
		{{$p.Name}}, err := {{ index $p.Type.Conv 0 }}segs[{{ $idx }}]{{ index $p.Type.Conv 1 }}
		if err != nil {
			bCtx.BadArgument(w, r, {{ $idx }}, err)
			return
		}
		{{ end }}
		{{ end }}
		{{ end }}
		f(
			w,
			r,
			{{- range $idx, $p := $sig.Params -}}
			{{- if index $p.Type.Conv 0 }}
			{{ $p.Name }},
			{{- else }}
			segs[{{ $idx }}],
			{{ end }}
			{{- end }}
		)
	}), nil
}
{{ end }}
`))
)

func writeFunctionFile(w io.Writer, sigs []Sig) error {
	imports := []string{"net/http"}
	{
		seen := make(map[string]bool)
		for _, sig := range sigs {
			for _, p := range sig.Params {
				for _, i := range p.Type.Imports {
					if !seen[i] {
						seen[i] = true
						imports = append(imports, i)
					}
				}
			}
		}
		sort.Strings(imports)
	}

	var buf bytes.Buffer
	if err := tmplFunc.Execute(&buf, struct {
		Sigs    []Sig
		Imports []string
	}{sigs, imports}); err != nil {
		return fmt.Errorf("tmplFunc.Execute: %v", err)
	}

	return writeFormatted(buf.Bytes(), w)
}
